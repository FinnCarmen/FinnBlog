+++
date = '2025-02-01T16:07:17+08:00'
draft = false
title = 'Floyd'
+++

## 1. 全局常量和数据结构

```cpp
const int INF = 1e9;  // 表示无穷大（实际上可以认为是一个很大的数字，用于初始化不可达的距离）
const int MAXN = 100; // 最大节点数
int dist[MAXN][MAXN]; // 距离矩阵，dist[i][j] 表示节点 i 到节点 j 的当前最短路径长度
int path[MAXN][MAXN]; // 路径矩阵，用于记录中间节点信息，便于重构路径
```

- **INF**：表示无穷大，用来初始化节点间的距离，表示两个节点之间暂时不可达。
- **dist[][]**：二维数组记录任意两个节点之间的最短路径距离。
- **path[][]**：二维数组记录在从 i 到 j 的最短路径中，最后一次更新时使用的中间节点。如果没有中间节点，则为 -1。

---

## 2. 初始化图

```cpp
void initializeGraph(int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == j)
            {
                dist[i][j] = 0;
                path[i][j] = -1;
            }
            else
            {
                dist[i][j] = INF;
                path[i][j] = -1;
            }
        }
    }
}
```

- **作用**：对图进行初始化。
  - 当 \(i == j\) 时，节点到自身的距离为 0；
  - 当 \(i \neq j\) 时，默认将距离设为 INF（表示初始时两节点间没有已知路径），并且路径矩阵初始化为 -1，表示没有中间节点。

---

## 3. 弗洛伊德算法核心实现

```cpp
void floydWarshall(int n)
{
    for (int k = 0; k < n; k++)
    {
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (dist[i][k] < INF && dist[k][j] < INF && dist[i][k] + dist[k][j] < dist[i][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}
```

### 算法思想

- **动态规划**：通过不断引入中间节点 \(k\)，更新任意两点 \(i\) 到 \(j\) 的最短距离。
- **三重循环**：
  - 外层循环：枚举所有可能作为中间节点的节点 \(k\)。
  - 中间和内层循环：枚举所有起点 \(i\) 和终点 \(j\) 的组合。

### 更新条件

- **检查可达性**：
  - `dist[i][k] < INF && dist[k][j] < INF` 确保从 \(i\) 到 \(k\) 和从 \(k\) 到 \(j\) 都是可达的（防止 INF 加法溢出）。
- **松弛操作**：
  - 如果经过中间节点 \(k\) 的路径 `dist[i][k] + dist[k][j]` 小于当前记录的 `dist[i][j]`，则更新最短距离：
    ```cpp
    dist[i][j] = dist[i][k] + dist[k][j];
    path[i][j] = k;
    ```
  - 同时记录下这个中间节点 \(k\) 到 `path[i][j]`，便于后续重构路径。

---

## 4. 路径输出（路径重构）

```cpp
void printPath(int u, int v)
{
    if (path[u][v] == -1)
    {
        if (u != v)
        {
            cout << u << " -> " << v;
        }
    }
    else
    {
        printPath(u, path[u][v]);
        cout << " -> ";
        printPath(path[u][v], v);
    }
}
```

### 递归重构路径

- **基本思想**：  
  如果 `path[u][v] == -1`，表示从 \(u\) 到 \(v\) 没有经过任何中间节点（即直达或 \(u == v\)），直接输出起点和终点。  
  否则，说明在 \(u\) 和 \(v\) 之间有一个中间节点 \(k\)（存储在 `path[u][v]` 中），将路径分解为两部分：
  - 从 \(u\) 到 \(k\)
  - 从 \(k\) 到 \(v\)  
    递归地调用 `printPath` 分别输出这两部分。

> **注意**：该递归方法在输出路径时，可能会重复打印一些节点或输出格式上需要调整，实际使用中可能需要改进以保证输出的路径格式更整洁。

---

## 5. 主函数

```cpp
int main()
{
    int n, m;
    cout << "请输入节点数和边数 (节点数 边数): ";
    cin >> n >> m;

    initializeGraph(n);

    cout << "请输入每条边的起点、终点和权重:" << endl;
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w; // 起点u, 终点v, 权重w
        dist[u][v] = w;     // 记录边的权重
    }

    floydWarshall(n);

    cout << "最短路径矩阵:" << endl;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (dist[i][j] == INF)
            {
                cout << "INF ";
            }
            else
            {
                cout << dist[i][j] << " ";
            }
        }
        cout << endl;
    }

    cout << "输入查询路径的起点和终点 (输入-1 -1结束):" << endl;
    while (true)
    {
        int u, v;
        cin >> u >> v;
        if (u == -1 && v == -1)
        {
            break;
        }
        if (dist[u][v] == INF)
        {
            cout << "节点 " << u << " 到节点 " << v << " 不可达" << endl;
        }
        else
        {
            cout << "节点 " << u << " 到节点 " << v << " 的最短路径长度为: " << dist[u][v] << endl;
            cout << "路径为: ";
            printPath(u, v);
            cout << endl;
        }
    }

    return 0;
}
```

### 主函数步骤解析

1. **输入图的基本信息**：

   - 输入节点数 `n` 和边数 `m`。

2. **初始化图**：

   - 调用 `initializeGraph(n)` 为所有节点间设置初始距离和路径信息。

3. **读入边信息**：

   - 循环 `m` 次，输入每条边的起点 `u`、终点 `v` 以及权重 `w`，并更新 `dist[u][v]`。

4. **计算所有节点对之间的最短路径**：

   - 调用 `floydWarshall(n)` 进行松弛操作，得到完整的最短路径矩阵和中间节点记录。

5. **输出最短路径矩阵**：

   - 遍历 `dist` 数组，若距离为 INF 则输出 "INF"，否则输出实际的最短距离。

6. **路径查询与输出**：
   - 进入循环，用户输入起点和终点，若输入为 `-1 -1` 则结束查询。
   - 如果 `dist[u][v]` 为 INF，则说明两节点之间不可达；否则输出最短距离和调用 `printPath(u, v)` 输出路径。

---

## 6. 小结

- **算法核心**：弗洛伊德算法利用动态规划思想，通过不断地引入中间节点来更新所有节点对之间的最短路径，时间复杂度为 \(O(n^3)\)。
- **路径重构**：借助 `path` 数组和递归方法，可以输出从起点到终点的具体经过哪些中间节点。
- **适用场景**：适用于节点数量较少（例如几十到一两百）的图的所有节点对最短路径问题，对于节点较多的情况需要考虑算法效率和空间消耗。
